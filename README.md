# SecretService

## Задача 

Необходимо сделать REST сервис для одноразовых 
секретов наподобие onetimesecret.com
Требуется реализовать две ручки:
```

POST /secret
```
Создание секрета

Запрос – JSON с текстом секрета
```
{
    "secret": "my secret"
}
```

Ответ:
{
    "secret_id": "bacdcf22f9185de9f0b2d39dad6e8440"
}

```
POST /secret/{secret_id}
```
Получение секрета 

Ответ:
```
{
    "secret": "my secret"
}
```

После получения секрета по определенному ключу дальнейшее обращение по нему сервер должен обрабатывать с кодом 404 а сам секрет удаляться из базы


## Требования 

Секреты и их ключи не хранятся в базе в открытом виде.
Код должен соответствовать PEP, необходимо использование type hints, к публичным методам должна быть написана документация.
Процент покрытия тестами – на свое усмотрение
Сервис должен корректно обрабатывать валидные и невалидные входящие запросы и выдавать соответствующие HTTP статусы
* Добавить возможность ограничения количества запросов – например, 600 в минуту. При превышении лимита, сервер должен возвращать статус 429. Логика ограничения должна быть написана самостоятельно. Готовые библиотеки использовать запрещено
* Все обернуть в докер

## Реализация 
( Добавила некоторый функционал для более завершенного функционала приложения )

* Дополниетльно добавлена возможность регистрации и аутенификации пользователя для того чтобы пользователь мог смотреть только свои секреты

* В модель (таблицу) секретов добавлено поле название и дата создания 

* В модель секрета так же добавлена уникальность на id пользователя и название секрета

* Добавлен энпонйт вывода всех секретов пользователя с возможностью фильтрации  по дате  от и до (
    секреты списком выводятся в зашифрованом формате - расшифруются только при получении одного секрета по id/uid
)
    если есть фильтр сереты фильтруются по дате создание от и до, а если фильтр не передан то выводятся в обратном порядке от самых новых к самым старым


* В энопйнты поиска и вывода всх секретов с возможностю фильтрации по дате добавлена пагинация

* Для ограничения количества запросов 600 в минуту добавлены на энпойнты создания секрета и чтение секрета   по id добавлены , middleware

* Шифрование секретов выполнено через библиотеку cryptography - для каждого секрета генериться индивидуальный ключ шифрования (байтовая строка) и сохраняется в базу данных - ключ никогда не выводится пользователю

* Выполено тестирование ключевых энпойнтов приложения с pytestasyncio


## Примечания

* Перед запуском приложения создать в корневой директории файл .env и добавить туда все переменные окружения
```#=== JWT ===#

JWT_SECRET_KEY=   
JWT_REFRESH_SECRET_KEY=


#=== Postgress ===#

POSTGRES_HOST=
POSTGRES_PORT=
POSTGRES_USER=
POSTGRES_PASSWORD=
POSTGRES_DB= 
```
## Запуск проекта 

* Создать файл .env в корневой директории проекта для сохранения переменных окружения
    ```
    POSTGRES_HOST = localhost
    POSTGRES_DB =  db
    POSTGRES_PORT = 5432
    POSTGRES_USER = admin
    POSTGRES_PASSWORD = postgres
    ```
* создать виртуальное окружение 
    ```
    python -m venv venv
    ```
* активировать виртуальное окружение
    для windows 
    ```
    venv/Scripts/activate.ps1
    ```

    для linux
    ```
    souece venv/bin/activate
    ``

* Установить зависисмости 
    ```pip install -r requirements.txt
    ```
* Проверить наличие директории versions в директории alembic - если ее нет - создать

* Запустить контейнеры в фоновом режиме 
  ```
  docker-compose up -d --build
  ```
* Проверить работоспособность эндпойнтов приложения
   ```
   cd src
   pytest
   ```
* Сделать стартовую миграцию 
   ```
   alembic revision --autogenerate -m "create all"
   ```

* Применить миграции
    ```
    alembic upgrade head
    ```
* Остановиить контейнеры (тк с флагом -d они запущены в фоновом режиме)

* Перезапустить приложение
    ```
    docker-compose up --build

    ```
Сваггер будет доступен по адресу 
```
http://127.0.0.1:8000/secret_service/docs
```
